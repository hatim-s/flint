# Flint Development Progress

## Completed Tasks

### 2026-02-01 - Task F1-001: TypeScript Strict Mode & Type Checking
**Status:** ✅ Completed
**Commit:** bd2aea6

**What was done:**
1. Updated tsconfig.json to enable additional strict type checks:
   - Added `noUncheckedIndexedAccess: true` to catch potential undefined array/object access
   - Added `noImplicitReturns: true` to ensure all code paths return values
   - Kept existing `strict: true` setting

2. Added typecheck script to package.json:
   - Added `"typecheck": "tsc --noEmit"` to scripts section
   - Can now run `bun run typecheck` for CI/pre-commit validation

3. Fixed all existing type errors:
   - Fixed components/ui/resizable.tsx import errors
   - Changed from namespace import to named imports: `Group`, `Panel`, `Separator`
   - Updated all component type references to use correct exports from react-resizable-panels

4. Verified all type checks pass successfully:
   - Ran `bun run typecheck` with zero errors

**Next Task:** F1-002 - GitHub OAuth Authentication

---

### 2026-02-04 - Task F1-002: GitHub OAuth Authentication
**Status:** Completed
**Commit:** 4c5da64

**What was done:**
1. Updated auth/index.ts to add GitHub OAuth provider configuration:
   - Added socialProviders.github with clientId and clientSecret from env vars
   - Configured session settings (7 days expiry, 1 day refresh, 5 min cookie cache)
   - Exported Session and User types for type safety

2. Added GITHUB_CLIENT_ID and GITHUB_CLIENT_SECRET placeholders to .env.local:
   - Included instructions for creating GitHub OAuth App
   - Callback URL: http://localhost:3000/api/auth/callback/github

3. Created API route for Better Auth:
   - app/api/auth/[...all]/route.ts - Catch-all route handling all auth endpoints
   - Uses toNextJsHandler from better-auth/next-js

4. Created auth client lib/auth-client.ts:
   - Uses createAuthClient from better-auth/react
   - Exports signIn, signOut, signUp, useSession, getSession helpers

5. Created login page app/(auth)/login/page.tsx:
   - Clean card-based UI with "Continue with GitHub" button
   - Loading state with spinner during OAuth flow
   - Error handling for failed sign-ins
   - Redirects to /dashboard after successful authentication

6. User avatar and name extraction:
   - Better Auth automatically extracts GitHub profile data (name, avatar_url)
   - Stored in user table's name and image fields

**Learnings:**
- Better Auth handles OAuth callbacks through the catch-all [...all] route automatically
- No need for separate callback route - the flow is: login -> GitHub -> /api/auth/callback/github -> session creation -> redirect
- Social provider configuration is straightforward - just clientId and clientSecret
- Type exports (Session, User) from auth config help with type safety across the app
- Cookie cache with session.cookieCache reduces database queries for session validation

**Next Task:** F1-003 - Protected & Public Route Separation

---

### 2026-02-04 - Task F1-003: Protected & Public Route Separation
**Status:** Completed
**Commit:** 9d1da6b

**What was done:**
1. Created middleware.ts at project root with session validation:
   - Validates Better Auth session via /api/auth/get-session endpoint
   - Handles both cookie existence check and session validity verification
   - Configures matcher to exclude static files and Next.js internals

2. Defined public routes:
   - PUBLIC_ROUTES: ['/', '/login', '/signup']
   - PUBLIC_API_ROUTES: ['/api/auth'] - Better Auth endpoints

3. Implemented redirect logic:
   - Unauthenticated users on protected routes -> /login with callbackUrl
   - Authenticated users on /login -> /dashboard
   - Preserves intended destination via callbackUrl query param

4. Created route groups:
   - app/(auth)/ - Login and signup pages
   - app/(protected)/ - Dashboard and other protected pages
   - Both with minimal layout.tsx files

5. Updated login page:
   - Now reads callbackUrl from search params
   - Redirects to original destination after successful OAuth

6. Created basic dashboard page:
   - Displays user info (name, avatar) from session
   - Sign out functionality with redirect to login
   - Uses Better Auth's useSession hook

**Learnings:**
- Middleware can fetch internal API routes to validate sessions
- Better Auth's get-session endpoint returns null for invalid sessions
- Using callbackUrl preserves user intent during auth redirects
- Route groups (auth), (protected) organize code without affecting URLs

**Next Task:** F1-004 - Core Database Schema - Notes & Journals

---

### 2026-02-04 - Task F1-004: Core Database Schema - Notes & Journals
**Status:** ✅ Completed
**Commit:** (pending)

**What was done:**
1. Created comprehensive database schema using Drizzle ORM:
   - db/schema/notes.ts: Notes table with id, userId, title, content, contentPlain, noteType (enum: 'note'|'journal'), sourceUrl, moodScore, qualityScore, templateId, timestamps, metadata (jsonb)
   - db/schema/tags.ts: Tags table with id, userId, name, color, createdAt
   - db/schema/noteTags.ts: Junction table with composite primary key (noteId, tagId)
   - db/schema/people.ts: People table for @mentions with id, userId, name, email, metadata
   - db/schema/noteMentions.ts: Junction table with composite primary key (noteId, personId)
   - db/schema/noteLinks.ts: Note relationships with id, sourceNoteId, targetNoteId, linkType (enum: 'reference'|'ai_suggested'|'manual'), strength, createdAt
   - db/schema/templates.ts: Templates table with id, userId, name, noteType, content, isDefault, createdAt

2. Added proper database features:
   - Foreign key constraints with onDelete: 'cascade' for data integrity
   - Indexes on frequently queried columns (userId, noteType, createdAt, etc.)
   - Unique constraints (tags per user, note links)
   - JSONB fields for flexible metadata storage
   - PostgreSQL enums for noteType and linkType

3. Set up relations in db/schema/index.ts:
   - Defined all Drizzle relations between tables for type-safe queries
   - Exported all schemas from a central index file
   - Extended user relations to include notes, tags, people, templates

4. Generated and pushed migrations:
   - Created migration file: drizzle/0001_daffy_the_order.sql
   - Successfully pushed schema to Neon database using `bun run db:push`
   - Verified schema is in sync (no changes detected on subsequent push)

5. Verified type safety:
   - Ran `bun run typecheck` with zero errors
   - All inferred types working correctly (Note, NewNote, Tag, etc.)

**Learnings:**
- Drizzle's type inference is excellent - $inferSelect and $inferInsert provide full type safety
- JSONB fields with $type<T>() allow structured metadata while maintaining flexibility
- Composite primary keys perfect for junction tables (no separate id needed)
- Cascade deletes ensure referential integrity when users/notes are deleted
- Indexes on foreign keys and commonly filtered columns improve query performance

**Next Task:** F1-005 - Row Level Security (RLS) for Neon

---

### 2026-02-04 - Task F1-005: Row Level Security (RLS) for Neon
**Status:** ✅ Completed
**Commit:** 3621c91

**What was done:**
1. Created comprehensive RLS policies in db/migrations/rls-policies.sql:
   - Enabled RLS on all user-scoped tables: notes, tags, people, templates, note_tags, note_mentions, note_links
   - Created policies for direct user tables (notes, tags, people, templates) using user_id = current_setting('app.current_user_id')
   - Created policies for junction tables that check ownership through foreign key relationships:
     * note_tags: Checks if user owns the note
     * note_mentions: Checks if user owns the note
     * note_links: Checks if user owns the source note (prevents cross-user link discovery)

2. Created db/lib/rls.ts helper module with three utilities:
   - setCurrentUser(userId): Sets the PostgreSQL session variable for RLS policies
   - withRLS(userId, operation): Wraps operations with automatic RLS context
   - scopedDb(userId): Creates a user-scoped database client for cleaner API

3. Implementation approach:
   - Used SET LOCAL app.current_user_id for transaction-scoped user context
   - Works with Neon's serverless HTTP connections (each request gets its own connection)
   - Junction table policies use EXISTS subqueries for efficient relationship checks
   - Text data type for user_id (matches Better Auth's user.id type)

4. Security considerations:
   - note_links policy checks source note ownership to prevent discovering other users' notes
   - All policies use current_setting with 'true' parameter to gracefully handle missing variable
   - Cascade deletes ensure RLS-protected data is cleaned up when users/notes are deleted

**To apply RLS:**
Run the SQL file in Neon console or via psql:
```bash
psql $DATABASE_URL -f db/migrations/rls-policies.sql
```

**Usage in API routes:**
```typescript
import { setCurrentUser } from '@/db/lib/rls';
import { db } from '@/db';
import { notes } from '@/db/schema/notes';

export async function GET(req: Request) {
  const session = await auth.api.getSession({ headers: req.headers });
  if (!session) return Response.json({ error: 'Unauthorized' }, { status: 401 });
  
  await setCurrentUser(session.user.id);
  const userNotes = await db.select().from(notes);
  return Response.json(userNotes);
}
```

**Learnings:**
- RLS provides database-level security as a safety net beyond application-level auth checks
- SET LOCAL is perfect for serverless environments where connections are short-lived
- Junction table policies need careful design to prevent information leakage through relationships
- current_setting('app.current_user_id', true) with true flag prevents errors when variable not set
- Testing RLS requires creating test users and verifying data isolation

**Next Task:** Phase 2 - Editor & Core Note Operations

---

### 2026-02-04 - Task F1-006: Full-Text Search Index Setup
**Status:** ✅ Completed
**Commit:** (pending)

**What was done:**
1. Created fulltext-search-index.sql migration:
   - Created GIN index on notes table: `notes_fts_idx` using `to_tsvector('english', content_plain || title)`
   - Added index on `updated_at` for efficient sorting by recency
   - Created PostgreSQL function `search_notes()` for consistent search behavior with ranking
   - Function supports pagination (limit/offset), filtering by user_id, and ts_rank scoring

2. Created db/lib/search.ts with comprehensive search utilities:
   - `SearchResult` interface extending Note with rank score
   - `SearchOptions` interface with filters (noteType, mood range, pagination)
   - `sanitizeSearchQuery()` function to prevent SQL injection and handle special characters
   - `searchNotes()` function using ts_rank for relevance scoring
   - `countSearchResults()` function for pagination metadata
   - Full integration with RLS using setCurrentUser()
   - Proper TypeScript type safety with Drizzle ORM

3. Created API route app/api/search/keyword/route.ts:
   - GET endpoint with query parameters: q, limit, offset, noteType, minMood, maxMood, includeCount
   - Comprehensive input validation (query required, limit 1-100, offset ≥0, mood scores 1-10)
   - Session authentication using Better Auth
   - Returns results with rank scores, count, and pagination metadata
   - Proper error handling with descriptive messages

4. Created db/migrations/README.md:
   - Documentation for applying SQL migrations
   - Instructions for both Neon Console and psql methods
   - Verification queries to check migration success
   - Troubleshooting guide

5. Verified type safety:
   - Ran `bun run typecheck` with zero errors
   - All function signatures properly typed
   - Integration with existing schema validated

**Technical Decisions:**
- Used PostgreSQL's native full-text search (tsvector/tsquery) instead of external search engines for cost optimization
- GIN index provides O(log n) search performance on text fields
- Combined title and content_plain in search vector for comprehensive matching
- ts_rank provides relevance scoring based on term frequency and document length
- plainto_tsquery sanitizes user input and handles phrase queries
- English text search configuration for proper stemming (e.g., "running" matches "run")
- Secondary sorting by updated_at ensures recent notes appear first for tied ranks

**To Apply Migration:**
Run in Neon SQL console or via psql:
```bash
psql $DATABASE_URL -f db/migrations/fulltext-search-index.sql
```

**Learnings:**
- PostgreSQL's full-text search is production-ready and eliminates need for Elasticsearch/Algolia
- GIN indexes are larger but much faster than GiST for text search (trade space for speed)
- ts_rank can be customized with weights for title vs content if needed
- plainto_tsquery handles most user queries, but to_tsquery could be used for advanced boolean operators
- COALESCE handles NULL content_plain gracefully (though schema should prevent NULLs)
- RLS integration ensures search respects user data boundaries at database level

**API Usage Example:**
```bash
# Basic search
GET /api/search/keyword?q=productivity

# Filtered search with pagination
GET /api/search/keyword?q=anxiety&noteType=journal&minMood=5&limit=10&offset=0&includeCount=true

# Mood range search
GET /api/search/keyword?q=work&minMood=7&maxMood=10
```

**Next Task:** F2-004 - Note CRUD API Routes

---

### 2026-02-04 - Task F2-004: Note CRUD API Routes
**Status:** ✅ Completed
**Commit:** (pending)

**What was done:**
1. Created lib/notes.ts with comprehensive CRUD operations:
   - Zod validation schemas: createNoteSchema, updateNoteSchema, listNotesSchema
   - Helper functions: createNote, getNote, updateNote, deleteNote, listNotes, getNoteCount
   - stripMarkdown() utility to convert markdown to plain text for search indexing
   - countWords() utility for metadata tracking
   - Full RLS integration using setCurrentUser()
   - Optimistic locking support via updatedAt timestamp comparison

2. Implemented createNote():
   - Accepts CreateNoteInput with validation
   - Strips markdown to create contentPlain for full-text search
   - Calculates word count and stores in metadata
   - Sets embeddingStatus to 'pending' for future AI processing
   - Returns created note with all fields

3. Implemented getNote():
   - Fetches single note by ID with RLS protection
   - Returns null if not found (respects user ownership)

4. Implemented updateNote():
   - Partial update support (all fields optional)
   - Optimistic locking: checks updatedAt matches before update
   - Re-strips markdown when content changes
   - Resets embeddingStatus to 'pending' when content changes
   - Preserves existing metadata and merges with updates
   - Returns error if note modified by another process

5. Implemented deleteNote():
   - Verifies note exists and user owns it before deletion
   - Cascade deletes handled by database (tags, mentions, links)

6. Implemented listNotes() with advanced features:
   - Cursor-based pagination (efficient for large datasets)
   - Filtering by: noteType, tags, mood range, date range
   - Sorting by: createdAt, updatedAt, title (asc/desc)
   - Tag filtering via junction table joins
   - Returns: notes array, nextCursor, hasMore flag
   - Fetches limit+1 to determine if more results exist

7. Created app/api/notes/route.ts:
   - GET /api/notes: List notes with query parameters
     * Support for all filters: limit, cursor, noteType, tags, minMood, maxMood, startDate, endDate, sortBy, sortOrder
     * Returns paginated results with nextCursor
   - POST /api/notes: Create new note
     * Validates input with Zod
     * Returns 201 Created with note data
   - Session authentication on all endpoints
   - Proper error handling: 400 for validation, 401 for auth, 500 for server errors

8. Created app/api/notes/[id]/route.ts:
   - GET /api/notes/[id]: Fetch single note
     * Returns 404 if note not found or not owned by user
   - PUT /api/notes/[id]: Update note
     * Supports partial updates
     * Returns 409 Conflict if optimistic lock fails
     * Returns 404 if note not found
   - DELETE /api/notes/[id]: Delete note
     * Returns 404 if note not found
     * Returns 200 with success message
   - All endpoints use async context.params for Next.js 15 compatibility

9. Verified type safety:
   - Ran `bun run typecheck` with zero errors
   - All Zod schemas properly typed
   - Full type inference from Drizzle schema
   - Proper error handling with TypeScript

**Technical Decisions:**
- Cursor-based pagination over offset-based for better performance at scale
- Strip markdown on server-side to ensure search index consistency
- Store word count in metadata for analytics/quality tracking
- Optimistic locking prevents lost updates in concurrent scenarios
- Set embeddingStatus to 'pending' when content changes to trigger re-embedding
- Tag filtering requires separate query to get tag IDs first, then filter notes
- Fetch limit+1 pattern to efficiently determine if more results exist without separate count query
- Zod validation at API boundary ensures type safety from client to database

**API Endpoints Created:**
```bash
# List notes
GET /api/notes?limit=20&noteType=journal&minMood=7&sortBy=updatedAt&sortOrder=desc

# Create note
POST /api/notes
Body: { title, content, noteType, sourceUrl?, moodScore?, templateId?, metadata? }

# Get single note
GET /api/notes/{id}

# Update note
PUT /api/notes/{id}
Body: { title?, content?, noteType?, sourceUrl?, moodScore?, metadata?, updatedAt? }

# Delete note
DELETE /api/notes/{id}
```

**Learnings:**
- Zod 4 requires explicit key type for z.record(): z.record(z.string(), z.unknown())
- Next.js 15 requires await context.params in route handlers
- Cursor-based pagination is more complex but scales better than offset
- Optimistic locking requires client to send updatedAt and server to compare timestamps
- Junction table queries require subqueries or joins to filter by related data
- RLS policies automatically handle user isolation at database level
- TypeScript inference from Drizzle schemas eliminates need for manual type definitions

**Next Task:** F2-001 - Markdown Editor Setup - TipTap Integration

---

### 2026-02-04 - Task F2-001: Markdown Editor Setup - TipTap Integration
**Status:** ✅ Completed
**Commit:** (pending)

**What was done:**
1. Installed TipTap packages (removed @tiptap/starter-kit to avoid version conflicts):
   - Core: @tiptap/react@3.19.0, @tiptap/pm@3.19.0, @tiptap/core@3.19.0
   - Extensions: Document, Paragraph, Text, Heading, Bold, Italic, Strike, Code, Blockquote
   - Lists: BulletList, OrderedList, ListItem, TaskList, TaskItem
   - Special: CodeBlock, Link, Image, Highlight, Typography, HardBreak, HorizontalRule
   - Utilities: Dropcursor, Gapcursor, History, Placeholder
   - Markdown: tiptap-markdown@0.9.0 for bidirectional markdown support

2. Created components/editor/TipTapEditor.tsx:
   - Main editor component with useEditor hook
   - All extensions configured with proper HTML attributes for styling
   - Markdown support via tiptap-markdown extension
   - getMarkdownFromEditor() helper to extract markdown from editor storage
   - Props: content, onChange, placeholder, editable, className
   - Auto-updates content when prop changes (with initial mount protection)
   - Exports helper functions: getMarkdown(), setMarkdown(), useEditor
   - Exports Editor type for parent components

3. Created components/editor/EditorToolbar.tsx:
   - Comprehensive formatting toolbar with all common markdown operations
   - Buttons: Bold, Italic, Strike, Code, Highlight
   - Headings: H1, H2, H3
   - Lists: Bullet, Ordered, Task/Checklist
   - Blocks: Quote, Code Block, Horizontal Rule
   - Media: Link, Image (with URL prompts)
   - Visual feedback: Active state styling for current format
   - Tooltips with keyboard shortcuts
   - Uses shadcn/ui components (Button, Separator, Tooltip)
   - Lucide icons for all toolbar buttons

4. Configured Tailwind Typography:
   - Added @tailwindcss/typography plugin via @plugin directive
   - Added custom CSS for TipTap editor in app/globals.css
   - ProseMirror styles: outline removal, placeholder styling
   - Task list styles: custom checkboxes with proper alignment
   - Code block styles: themed background and syntax highlighting support
   - Highlight/mark styles: light/dark mode support
   - Prose classes configured in editor: prose-sm to prose-xl responsive

5. Created components/editor/index.tsx:
   - Central export file for all editor components
   - Exports: TipTapEditor, EditorToolbar, useEditor, getMarkdown, setMarkdown
   - Export types: Editor

6. Removed old placeholder components:
   - Deleted components/editor.tsx (old TipTap demo file with StarterKit dependency)

7. Verified type safety:
   - Ran `bun run typecheck` with zero errors
   - All components properly typed
   - Editor hook returns correctly typed Editor instance

**Technical Decisions:**
- Removed @tiptap/starter-kit to avoid version conflicts between bundled @tiptap/core
- Using individual extensions gives more control and avoids dependency conflicts
- Markdown extension provides bidirectional conversion (paste markdown, export markdown)
- Storage API used for markdown extraction: editor.storage.markdown.getMarkdown()
- Tailwind v4 @plugin syntax for typography instead of config file
- Custom CSS for TipTap-specific styles (placeholder, task lists, code blocks)
- Toolbar is separate component to allow flexible layout (can be positioned anywhere)
- All extensions configured with Tailwind classes for consistent theming

**Component Structure:**
```
components/editor/
├── TipTapEditor.tsx       # Main editor component
├── EditorToolbar.tsx      # Formatting toolbar
└── index.tsx              # Central exports
```

**Usage Example:**
```typescript
import { TipTapEditor, EditorToolbar, useEditor } from '@/components/editor';

function NoteEditor() {
  const [markdown, setMarkdown] = useState('');
  
  return (
    <div>
      <EditorToolbar editor={editor} />
      <TipTapEditor 
        content={markdown}
        onChange={setMarkdown}
        placeholder="Start writing..."
        editable={true}
      />
    </div>
  );
}
```

**Learnings:**
- @tiptap/starter-kit bundles its own @tiptap/core which causes type conflicts
- Individual extensions provide better version control and smaller bundle size
- tiptap-markdown storage API is accessed via type assertion on editor.storage
- Tailwind v4 uses @plugin directive instead of tailwind.config.js
- TipTap's placeholder extension requires custom CSS for proper styling
- Task lists need special styling for checkboxes to align properly
- Editor content updates need protection against infinite loops (useRef for initial mount)

**Next Task:** F2-002 - Tag System with Autocomplete

---

## Pending Tasks
- Phase 1 Complete! ✅
- Phase 2: Editor & Core Note Operations
  - F2-001: Markdown Editor Setup - TipTap Integration ✅ COMPLETE
  - F2-002: Tag System with Autocomplete
  - F2-003: People Mentions with @mention
  - F2-004: Note CRUD API Routes ✅ COMPLETE
  - F2-005: Note Creation Modal & Flow
  - F2-006: Template System
  - F2-007: Note Editor Page

### 2026-02-04 - Task F2-007: Note Editor Page
**Status:** ✅ Completed
**Commit:** (pending)

**What was done:**
1. Created components/editor/LiveTrackers.tsx sidebar component:
   - Mood tracker with slider (1-10 scale) with color-coded labels
   - Dynamic mood labels: Very Low (1-2), Low (3-4), Neutral (5-6), Good (7-8), Excellent (9-10)
   - Word count statistics display
   - Note type badge (Journal/Note)
   - Related Notes placeholder section for future Serendipity Engine integration
   - Card-based UI using shadcn/ui components
   - Responsive design with proper spacing and typography

2. Created app/(protected)/notes/[id]/page.tsx - Complete note editing experience:
   - Full-page editor layout with header, main content area, and sidebar
   - Breadcrumb navigation: Dashboard > Notes > [Note Title]
   - Title input with inline editing and note type badge
   - Integration with TipTapEditor component for markdown editing
   - LiveTrackers sidebar for mood and statistics (70/30 split on desktop, stacked on mobile)

3. Implemented auto-save functionality:
   - Debounced auto-save (2 seconds after last keystroke)
   - Optimistic locking using updatedAt timestamp to prevent conflicts
   - Save status indicator with four states:
     * Saved (green checkmark)
     * Saving... (blue spinner)
     * Unsaved changes (orange warning)
     * Error saving (red error)
   - Manual save button (disabled when already saved or saving)
   - Conflict detection: warns user if note was modified elsewhere

4. Implemented delete functionality:
   - Delete button with AlertDialog confirmation
   - Destructive action styling (red button)
   - Loading state during deletion
   - Automatic redirect to dashboard after successful deletion
   - Toast notifications for success/error feedback

5. Added comprehensive error handling:
   - 404 handling: redirects to dashboard if note not found
   - Network error handling with toast notifications
   - Loading state with spinner while fetching note data
   - Graceful handling of concurrent modification conflicts (409 Conflict)

6. Responsive layout:
   - Grid layout: 1fr_350px on desktop (70/30 split)
   - Stacks vertically on mobile
   - Overflow handling for long content
   - Proper scrolling for editor and sidebar independently

7. Updated components/editor/index.tsx:
   - Added LiveTrackers to exports for easy importing

8. Verified type safety:
   - Ran `bun run typecheck` with zero errors
   - All async params properly handled with React.use()
   - Proper typing for all state variables and API responses

**Technical Decisions:**
- Used React.use() for async params (Next.js 15 pattern)
- Auto-save triggers on any change to title, content, or moodScore
- Debounce timeout set to 2 seconds for optimal UX (not too aggressive, not too slow)
- Optimistic locking prevents lost updates in concurrent editing scenarios
- Word count calculation uses simple split on whitespace (can enhance later with better parsing)
- Mood tracker defaults to 5 (neutral) if not set
- Editor and sidebar scroll independently for better UX with long notes
- Toast notifications provide user feedback without blocking interactions
- Breadcrumbs use icons for visual clarity (Home, FileText)

**Component Structure:**
```
app/(protected)/notes/[id]/
└── page.tsx              # Main editor page

components/editor/
├── TipTapEditor.tsx      # Markdown editor component
├── LiveTrackers.tsx      # Sidebar with mood/stats
├── EditorToolbar.tsx     # Formatting toolbar
└── index.tsx             # Central exports
```

**Features Implemented:**
✅ Fetch note data from API with loading state
✅ Title editing with inline input
✅ Markdown content editing with TipTapEditor
✅ Auto-save with debouncing (2 seconds)
✅ Manual save button
✅ Save status indicator (4 states)
✅ Optimistic locking for conflict prevention
✅ Mood tracker with slider (1-10)
✅ Word count display
✅ Note type badge
✅ Delete with confirmation dialog
✅ Breadcrumb navigation
✅ Responsive layout (70/30 desktop, stacked mobile)
✅ Error handling and loading states
✅ Toast notifications for feedback

**Learnings:**
- Next.js 15 requires React.use() for async params instead of direct destructuring
- Auto-save with debouncing provides better UX than save-on-blur or manual-only
- Optimistic locking is critical for preventing lost updates in collaborative environments
- Save status indicators reduce user anxiety about data loss
- Separate scroll areas for editor and sidebar improve UX with long content
- AlertDialog provides better UX than window.confirm for destructive actions
- Toast notifications are non-blocking and don't interrupt user workflow
- Grid layout with fixed sidebar width provides consistent UX across screen sizes

**Next Task:** F2-005 - Note Creation Modal & Flow or F2-002 - Tag System with Autocomplete

---

## Pending Tasks
- Phase 1 Complete! ✅
- Phase 2: Editor & Core Note Operations
  - F2-001: Markdown Editor Setup - TipTap Integration ✅ COMPLETE
  - F2-002: Tag System with Autocomplete
  - F2-003: People Mentions with @mention
  - F2-004: Note CRUD API Routes ✅ COMPLETE
  - F2-005: Note Creation Modal & Flow
  - F2-006: Template System
  - F2-007: Note Editor Page ✅ COMPLETE

